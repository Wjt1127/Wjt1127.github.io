<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wjt1127 Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Wjt1127 Blog">
<meta property="og:url" content="https://wjt1127.github.io/index.html">
<meta property="og:site_name" content="Wjt1127 Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Wjt1127">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Wjt1127 Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wjt1127 Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wjt1127.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-copy-cow-page-dax" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/30/copy-cow-page-dax/" class="article-date">
  <time class="dt-published" datetime="2022-09-30T02:51:14.000Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="fs-dax-c-–-gt-copy-cow-page-dax"><a href="#fs-dax-c-–-gt-copy-cow-page-dax" class="headerlink" title="fs\dax.c –&gt; copy_cow_page_dax()"></a>fs\dax.c –&gt; copy_cow_page_dax()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_cow_page_dax</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf, <span class="type">const</span> <span class="keyword">struct</span> iomap_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pgoff_t</span> pgoff = dax_iomap_pgoff(&amp;iter-&gt;iomap, iter-&gt;pos);<span class="comment">/* dax_iomap_pgoff -&gt; PHYS_PFN ：获得物理页框号*/</span></span><br><span class="line">	<span class="type">void</span> *vto, *kaddr;</span><br><span class="line">	<span class="type">long</span> rc;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	id = dax_read_lock();</span><br><span class="line">	rc = dax_direct_access(iter-&gt;iomap.dax_dev, pgoff, <span class="number">1</span>, DAX_ACCESS,</span><br><span class="line">				&amp;kaddr, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dax_read_unlock(id);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line">	vto = kmap_atomic(vmf-&gt;cow_page);</span><br><span class="line">	copy_user_page(vto, kaddr, vmf-&gt;address, vmf-&gt;cow_page);</span><br><span class="line">	kunmap_atomic(vto);</span><br><span class="line">	dax_read_unlock(id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="include-linux-iomap-h-–-gt-struct-iomap-iter"><a href="#include-linux-iomap-h-–-gt-struct-iomap-iter" class="headerlink" title="include/linux/iomap.h –&gt; struct iomap_iter"></a>include/linux/iomap.h –&gt; struct iomap_iter</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct iomap_iter - Iterate through a range of a file(遍历文件的某一范围)</span></span><br><span class="line"><span class="comment"> * @inode: Set at the start of the iteration and should not change.</span></span><br><span class="line"><span class="comment"> * @pos: The current file position we are operating on.  It is updated by</span></span><br><span class="line"><span class="comment"> *	calls to iomap_iter().  Treat as read-only in the body.</span></span><br><span class="line"><span class="comment"> * @len: The remaining length of the file segment we&#x27;re operating on.</span></span><br><span class="line"><span class="comment"> *	It is updated at the same time as @pos.</span></span><br><span class="line"><span class="comment"> * @processed: The number of bytes processed by the body in the most recent</span></span><br><span class="line"><span class="comment"> *	iteration, or a negative errno. 0 causes the iteration to stop.</span></span><br><span class="line"><span class="comment"> * @flags: Zero or more of the iomap_begin flags above.</span></span><br><span class="line"><span class="comment"> * @iomap: Map describing the I/O iteration</span></span><br><span class="line"><span class="comment"> * @srcmap: Source map for COW operations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iomap_iter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> pos;</span><br><span class="line">	u64 len;</span><br><span class="line">	s64 processed;</span><br><span class="line">	<span class="type">unsigned</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iomap</span> <span class="title">iomap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iomap</span> <span class="title">srcmap</span>;</span></span><br><span class="line">	<span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="drivers-dax-super-c-–-gt-dax-direct-access"><a href="#drivers-dax-super-c-–-gt-dax-direct-access" class="headerlink" title="/drivers/dax/super.c –&gt; dax_direct_access()"></a>/drivers/dax/super.c –&gt; dax_direct_access()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dax_direct_access() - translate a device pgoff to an absolute pfn</span></span><br><span class="line"><span class="comment"> * @dax_dev: a dax_device instance representing the logical memory range</span></span><br><span class="line"><span class="comment"> * @pgoff: offset in pages from the start of the device to translate</span></span><br><span class="line"><span class="comment"> 			从设备开始翻译，以页为单位的偏移量</span></span><br><span class="line"><span class="comment"> * @nr_pages: number of consecutive pages caller can handle relative to @pfn</span></span><br><span class="line"><span class="comment"> * @mode: indicator on normal access or recovery write</span></span><br><span class="line"><span class="comment"> * @kaddr: output parameter that returns a virtual address mapping of pfn</span></span><br><span class="line"><span class="comment"> * @pfn: output parameter that returns an absolute pfn translation of @pgoff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: negative errno if an error occurs, otherwise the number of</span></span><br><span class="line"><span class="comment"> * pages accessible at the device relative @pgoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">dax_direct_access</span><span class="params">(<span class="keyword">struct</span> dax_device *dax_dev, <span class="type">pgoff_t</span> pgoff, <span class="type">long</span> nr_pages,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> dax_access_mode mode, <span class="type">void</span> **kaddr, <span class="type">pfn_t</span> *pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> avail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dax_dev)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dax_alive(dax_dev))</span><br><span class="line">		<span class="keyword">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_pages &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	avail = dax_dev-&gt;ops-&gt;direct_access(dax_dev, pgoff, nr_pages,</span><br><span class="line">			mode, kaddr, pfn);</span><br><span class="line">	<span class="keyword">if</span> (!avail)</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line">	<span class="keyword">return</span> min(avail, nr_pages);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(dax_direct_access);</span><br></pre></td></tr></table></figure>



<h1 id="include-linux-dax-h-–-gt-dax-operrations-gt-direct-access"><a href="#include-linux-dax-h-–-gt-dax-operrations-gt-direct-access" class="headerlink" title="/include/linux/dax.h  –&gt;  dax_operrations-&gt;direct_access()"></a>/include/linux/dax.h  –&gt;  dax_operrations-&gt;direct_access()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dax_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * direct_access: translate a device-relative</span></span><br><span class="line"><span class="comment">	 * logical-page-offset into an absolute physical pfn. Return the</span></span><br><span class="line"><span class="comment">	 * number of pages available for DAX at that pfn.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">long</span> (*direct_access)(<span class="keyword">struct</span> dax_device *, <span class="type">pgoff_t</span>, <span class="type">long</span>,</span><br><span class="line">			<span class="keyword">enum</span> dax_access_mode, <span class="type">void</span> **, <span class="type">pfn_t</span> *);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Validate whether this device is usable as an fsdax backing</span></span><br><span class="line"><span class="comment">	 * device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*dax_supported)(<span class="keyword">struct</span> dax_device *, <span class="keyword">struct</span> block_device *, <span class="type">int</span>,</span><br><span class="line">			<span class="type">sector_t</span>, <span class="type">sector_t</span>);</span><br><span class="line">	<span class="comment">/* zero_page_range: required operation. Zero page range   */</span></span><br><span class="line">	<span class="type">int</span> (*zero_page_range)(<span class="keyword">struct</span> dax_device *, <span class="type">pgoff_t</span>, <span class="type">size_t</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * recovery_write: recover a poisoned range by DAX device driver</span></span><br><span class="line"><span class="comment">	 * capable of clearing poison.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">size_t</span> (*recovery_write)(<span class="keyword">struct</span> dax_device *dax_dev, <span class="type">pgoff_t</span> pgoff,</span><br><span class="line">			<span class="type">void</span> *addr, <span class="type">size_t</span> bytes, <span class="keyword">struct</span> iov_iter *iter);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="drivers-nvdimm-pmem-c-中"><a href="#drivers-nvdimm-pmem-c-中" class="headerlink" title="/drivers/nvdimm/pmem.c 中 :"></a>/drivers/nvdimm/pmem.c 中 :</h1><ul>
<li>.direct_access = pmem_dax_direct_access</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dax_operations</span> <span class="title">pmem_dax_ops</span> =</span> &#123;</span><br><span class="line">	.direct_access = pmem_dax_direct_access,</span><br><span class="line">	.zero_page_range = pmem_dax_zero_page_range,</span><br><span class="line">	.recovery_write = pmem_recovery_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="drivers-nvdimm-pmem-c"><a href="#drivers-nvdimm-pmem-c" class="headerlink" title="/drivers/nvdimm/pmem.c"></a>/drivers/nvdimm/pmem.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pmem_dax_direct_access</span><span class="params">(<span class="keyword">struct</span> dax_device *dax_dev,</span></span><br><span class="line"><span class="params">		<span class="type">pgoff_t</span> pgoff, <span class="type">long</span> nr_pages, <span class="keyword">enum</span> dax_access_mode mode,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> **kaddr, <span class="type">pfn_t</span> *pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pmem_device</span> *<span class="title">pmem</span> =</span> dax_get_private(dax_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __pmem_direct_access(pmem, pgoff, nr_pages, mode, kaddr, pfn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="drivers-nvdimm-pmem-c-1"><a href="#drivers-nvdimm-pmem-c-1" class="headerlink" title="/drivers/nvdimm/pmem.c"></a>/drivers/nvdimm/pmem.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* see &quot;strong&quot; declaration in tools/testing/nvdimm/pmem-dax.c */</span></span><br><span class="line">__weak <span class="type">long</span> __pmem_direct_access(<span class="keyword">struct</span> pmem_device *pmem, <span class="type">pgoff_t</span> pgoff,</span><br><span class="line">		<span class="type">long</span> nr_pages, <span class="keyword">enum</span> dax_access_mode mode, <span class="type">void</span> **kaddr,</span><br><span class="line">		<span class="type">pfn_t</span> *pfn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* pgoff 是在设备起始地址开始的页偏移量 */</span> </span><br><span class="line">	<span class="type">resource_size_t</span> offset = PFN_PHYS(pgoff) + pmem-&gt;data_offset;</span><br><span class="line">	<span class="type">sector_t</span> sector = PFN_PHYS(pgoff) &gt;&gt; SECTOR_SHIFT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num = PFN_PHYS(nr_pages) &gt;&gt; SECTOR_SHIFT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">badblocks</span> *<span class="title">bb</span> =</span> &amp;pmem-&gt;bb;</span><br><span class="line">	<span class="type">sector_t</span> first_bad;</span><br><span class="line">	<span class="type">int</span> num_bad;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kaddr)</span><br><span class="line">		*kaddr = pmem-&gt;virt_addr + offset; <span class="comment">//填充 pmem 对应的虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (pfn)</span><br><span class="line">		*pfn = <span class="type">phys_to_pfn_t</span>(pmem-&gt;phys_addr + offset, pmem-&gt;pfn_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bb-&gt;count &amp;&amp;</span><br><span class="line">	    badblocks_check(bb, sector, num, &amp;first_bad, &amp;num_bad)) &#123;</span><br><span class="line">		<span class="type">long</span> actual_nr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mode != DAX_RECOVERY_WRITE)</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Set the recovery stride is set to kernel page size because</span></span><br><span class="line"><span class="comment">		 * the underlying driver and firmware clear poison functions</span></span><br><span class="line"><span class="comment">		 * don&#x27;t appear to handle large chunk(such as 2MiB) reliably.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		actual_nr = PHYS_PFN(</span><br><span class="line">			PAGE_ALIGN((first_bad - sector) &lt;&lt; SECTOR_SHIFT));</span><br><span class="line">		dev_dbg(pmem-&gt;bb.dev, <span class="string">&quot;start sector(%llu), nr_pages(%ld), first_bad(%llu), actual_nr(%ld)\n&quot;</span>,</span><br><span class="line">				sector, nr_pages, first_bad, actual_nr);</span><br><span class="line">		<span class="keyword">if</span> (actual_nr)</span><br><span class="line">			<span class="keyword">return</span> actual_nr;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If badblocks are present but not in the range, limit known good range</span></span><br><span class="line"><span class="comment">	 * to the requested range.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bb-&gt;count)</span><br><span class="line">		<span class="keyword">return</span> nr_pages;</span><br><span class="line">	<span class="keyword">return</span> PHYS_PFN(pmem-&gt;size - pmem-&gt;pfn_pad - offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="include-linux-highmem-h-–-gt-kmap-atomic"><a href="#include-linux-highmem-h-–-gt-kmap-atomic" class="headerlink" title="/include/linux/highmem.h –&gt; kmap_atomic()"></a>/include/linux/highmem.h –&gt; kmap_atomic()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmap_atomic - Atomically map a page for temporary usage - Deprecated!</span></span><br><span class="line"><span class="comment"> * @page:	Pointer to the page to be mapped</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: The virtual address of the mapping</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In fact a wrapper around kmap_local_page() which also disables pagefaults</span></span><br><span class="line"><span class="comment"> * and, depending on PREEMPT_RT configuration, also CPU migration and</span></span><br><span class="line"><span class="comment"> * preemption. Therefore users should not count on the latter two side effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Mappings should always be released by kunmap_atomic().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not use in new code. Use kmap_local_page() instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is used in atomic context when code wants to access the contents of a</span></span><br><span class="line"><span class="comment"> * page that might be allocated from high memory (see __GFP_HIGHMEM), for</span></span><br><span class="line"><span class="comment"> * example a page in the pagecache.  The API has two functions, and they</span></span><br><span class="line"><span class="comment"> * can be used in a manner similar to the following::</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Find the page of interest.</span></span><br><span class="line"><span class="comment"> *   struct page *page = find_get_page(mapping, offset);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Gain access to the contents of that page.</span></span><br><span class="line"><span class="comment"> *   void *vaddr = kmap_atomic(page);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Do something to the contents of that page.</span></span><br><span class="line"><span class="comment"> *   memset(vaddr, 0, PAGE_SIZE);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Unmap that page.</span></span><br><span class="line"><span class="comment"> *   kunmap_atomic(vaddr);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the kunmap_atomic() call takes the result of the kmap_atomic()</span></span><br><span class="line"><span class="comment"> * call, not the argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you need to map two pages because you want to copy from one page to</span></span><br><span class="line"><span class="comment"> * another you need to keep the kmap_atomic calls strictly nested, like:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * vaddr1 = kmap_atomic(page1);</span></span><br><span class="line"><span class="comment"> * vaddr2 = kmap_atomic(page2);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * memcpy(vaddr1, vaddr2, PAGE_SIZE);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kunmap_atomic(vaddr2);</span></span><br><span class="line"><span class="comment"> * kunmap_atomic(vaddr1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/09/30/copy-cow-page-dax/" data-id="cl919s0ql0001qk7wfusa23eh" data-title="" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COW/" rel="tag">COW</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XFS/" rel="tag">XFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reflink/" rel="tag">reflink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CreateObj-in-PMDK" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/19/CreateObj-in-PMDK/" class="article-date">
  <time class="dt-published" datetime="2022-07-19T14:22:49.000Z" itemprop="datePublished">2022-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/19/CreateObj-in-PMDK/">CreateObj in PMDK</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​    为了完成CoW_PM项目，首先得实现一个createobj()的函数，它由fd和offset生成一个obj，并返回该obj的标识。PMDK的pmemobj_create()函数的功能类似，故学习一下它是如何实现的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/19/CreateObj-in-PMDK/" data-id="cl919s0qf0000qk7whk1vbaje" data-title="CreateObj in PMDK" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PMDK/" rel="tag">PMDK</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指-Offer-II-041-滑动窗口的平均值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/16/%E5%89%91%E6%8C%87-Offer-II-041-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2022-07-16T12:11:48.000Z" itemprop="datePublished">2022-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/16/%E5%89%91%E6%8C%87-Offer-II-041-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/">剑指 Offer II 041. 滑动窗口的平均值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/16/%E5%89%91%E6%8C%87-Offer-II-041-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/" data-id="cl5qviau10001sk7wc8yk5nqw" data-title="剑指 Offer II 041. 滑动窗口的平均值" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/easy/" rel="tag">easy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PS-ORAM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/PS-ORAM/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T11:15:27.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/15/PS-ORAM/">PS-ORAM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Oblivious-RAM"><a href="#Oblivious-RAM" class="headerlink" title="Oblivious RAM"></a>Oblivious RAM</h3><p>​    ORAM(Oblivious Read Access Machine)是指一种计算机，可以实现对于输入X,Y，产生的一系列指令是不可区分的。不经意随机访问机是一种重要的保护访问模式的手段，它通过混淆每一次访问过程，使其与随机访问不可区分，从而保护真实访问中的访问操作、访问位置等信息。</p>
<p>​    最近这么火，是由于云计算的迅猛发展，越来越多的企业和个人把数据外包到位于公有云上，然后数据安全和隐私保护就显得越来越重要。即云环境下的数据的机密性保护成为了重要的研究课题。常见的保护方式是在数据上传到云服务器上前进行加密，但是即使数据加密，攻击者也可以从数据访问模式（Access Patterns）推测出敏感信息。这里的访问模式是指程序对存储器的一系列访问所泄露的信息，包括命令（读或写）、地址和数据。已有工作证明攻击者可以从访问模式推测出敏感信息。</p>
<p>​    ORAM 近来就是来解决这个问题，隐藏数据的访问模式。比如一种简单的方案，就是每次把云上存储的数据都读到本地，然后找到自己需要读取或者更新的数据，然后再全部写回到云服务器上。这样云服务器就不知道你读了或者更新了什么数据。这就是一种最简单的 ORAM 方案，只是开销太大了，ORAM 研究的一大方向就是针对计算复杂度和带宽开销进行优化。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45314262/answer/275838233">https://www.zhihu.com/question/45314262/answer/275838233</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/15/PS-ORAM/" data-id="cl5qviatw0000sk7w5m6gbv1i" data-title="PS-ORAM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2022/" rel="tag">2022</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ISAC/" rel="tag">ISAC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/" rel="tag">Security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SubZero" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/13/SubZero/" class="article-date">
  <time class="dt-published" datetime="2022-07-13T02:37:42.000Z" itemprop="datePublished">2022-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/13/SubZero/">SubZero</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>论文链接:<a target="_blank" rel="noopener" href="https://par.nsf.gov/servlets/purl/10204132">SubZero: Zero-copy IO for Persistent Main Memory File Systems</a></p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>​    POSIX标准的 read() 和 write() 长期以来一直是访问文件中数据的标准接口。但是，当文件存储在 PMEM 中时，这些方法会带来冗余的数据拷贝开销。为了避免这种数据复制，PMEM 感知型文件系统(如NOVA、PMFS等)使用 DAX 技术通过总线直接访问 PM，但这样做需要程序员管理对文件的写入原子性和并发访问。</p>
<p>​    所以 SubZero 希望结合 POSIX IO 和 DAX IO 两者的优势，提供类似 DAX 的速度和一个简单的、类似 POSIX 的接口。</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>​    SubZero IO实现了以下的系统调用：</p>
<p><img src="./../images/SubZero%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="SubZero系统调用"></p>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p>​    peek () 系统调用将 PM 文件映射到内存中，并返回一个指向内存区域的指针，该内存区域包含特定文件偏移处的文件内容。映射的内存区域就是<strong>执行 peek () 时</strong>文件内容的快照，该快照对于文件修改（例如 write () 或 patch () ）是原子的。映射使用 O_RDONLY 标志位，使得快照是只读的、不可变的，因此尝试更改其内容会导致Segmentation Fault。</p>
<p>​    peek() 与 mmap() 相比，peek() 的文件偏移或返回的指针没有对齐限制，而 mmap() 需要页对齐。</p>
<hr>
<p>​    **peek() example1：basic **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek the first 4KB of a PMEM file</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_RDONLY); <span class="comment">// Open the target file</span></span><br><span class="line"><span class="type">char</span> *buf = peek(fd, <span class="number">0</span>, <span class="number">4096</span>); <span class="comment">// Peek its contents</span></span><br><span class="line"><span class="built_in">printf</span>(“%s\n”, buf); <span class="comment">// Print the contents</span></span><br><span class="line">unpeek(buf); <span class="comment">// Unpeek the contents</span></span><br></pre></td></tr></table></figure>

<hr>
<p>​    <strong>peek() example2：immutability</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek the first 4KB of a PMEM file</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_RDONLY); <span class="comment">// Open the target file</span></span><br><span class="line"><span class="type">char</span> *buf = peek(fd, <span class="number">0</span>, <span class="number">4096</span>); <span class="comment">// Peek its contents</span></span><br><span class="line"><span class="built_in">printf</span>(“%s\n”, buf); <span class="comment">// Print the contents</span></span><br><span class="line">*buf = ‘a’; <span class="comment">// Segmentation fault!</span></span><br><span class="line">unpeek(buf); <span class="comment">// Unpeek the contents</span></span><br></pre></td></tr></table></figure>

<hr>
<p>​    **peek() example3：isolation **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1: peek the first 4KB of a PMEM file</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> *buf = peek(fd, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”, buf); <span class="comment">// print original contents!</span></span><br><span class="line">...</span><br><span class="line">unpeek(buf);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2: update the peek()’ed region</span></span><br><span class="line"><span class="comment">// of the same file</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_WRONLY);</span><br><span class="line"><span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0xab</span>, <span class="number">4096</span>);</span><br><span class="line">write(fd, buf, <span class="number">4096</span>); <span class="comment">// copy-on-write to</span></span><br><span class="line">... <span class="comment">// a new 4KB</span></span><br><span class="line"><span class="built_in">free</span>(buf)</span><br><span class="line">close(fd); </span><br></pre></td></tr></table></figure>



<h3 id="patch"><a href="#patch" class="headerlink" title="patch()"></a>patch()</h3><p>​    patch() 系统调用通过将缓冲区的内容合并到给定偏移量的文件中来修改文件。本质上，缓冲区成为文件的一部分，而不是被复制到文件中。在 patch() 之后，缓冲区变得不可变。</p>
<p><img src="./../images/patch%E6%93%8D%E4%BD%9C.png" alt="patch操作"></p>
<p>​    这个 buffer 需要 access-aligned 。直观地说，就是缓冲区的页边界必须与文件中的页边界对齐。比如：对于在页大小为 S 的文件系统上使用缓冲区 B 和文件偏移 off 关闭的 patch() 操作，如果 B % S == off % S，则 patch() 是访问对齐的。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>​    为了展示它的潜力，在 PMEM 文件系统 XFS-DAX 和 NOVA 中实现了 SubZero。通过简单的基准测试表明，SubZero 可以比基于复制的 read() 和 write() 性能高出 2 倍和 2.8 倍。在应用层面，peek() 将 Apache Web Server 的 GET 性能提升了 3.6 倍，patch() 将 Kyoto Cabinet 的 SET 性能提升 1.3 倍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/13/SubZero/" data-id="cl5jjufz20000oc7w6xy62jd9" data-title="SubZero" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DAX/" rel="tag">DAX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zero-Copy/" rel="tag">Zero Copy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="tag">论文阅读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mmap整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/12/mmap%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-07-12T08:21:55.000Z" itemprop="datePublished">2022-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/12/mmap%E6%95%B4%E7%90%86/">mmap整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="mmap是什么"><a href="#mmap是什么" class="headerlink" title="mmap是什么"></a>mmap是什么</h2><p>​    mmap就是memory map，是内存映射。</p>
<p>​    mmap 是一种内存映射文件的方法，它将一个文件或者其它对象映射到用户进程的虚拟地址空间，实现文件磁盘地址(可以不连续)和进程虚拟地址空间中一段连续虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/12/mmap%E6%95%B4%E7%90%86/" data-id="cl5jjufz60001oc7w6nv81gil" data-title="mmap整理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mmap/" rel="tag">mmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第三章-内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-07-11T01:39:41.000Z" itemprop="datePublished">2022-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">第三章:内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="内存管理框架"><a href="#内存管理框架" class="headerlink" title="内存管理框架"></a>内存管理框架</h2><p>​    内存管理子系统的架构如下图所示，分为用户空间、内核空间和硬件 3 个层面。</p>
<p><img src="./../images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6.png" alt="内存管理框架"></p>
<h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>​    应用程序使用 malloc() 申请内存，使用 free() 释放内存。</p>
<p>​    malloc() 和 free() 是 glibc 库的内存分配器 ptmalloc 提供的接口， ptmalloc 使用系统调用 brk 或 mmap 向内 核以页为单位申请内存 ， 然后划分成小内存块分配给应用程序。</p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>​    （1）内核空间的基本功能</p>
<p>​    虚拟内存管理负责从进程的虚拟地址空间分配虚拟页， sys_brk 用来扩大或收缩堆， sys_mmap 用来在内存映射区域分配虚拟页， sys_munmap 用来释放虚拟页。</p>
<p>​    <strong>内核使用延迟分配物理内存的策略，进程第 1 次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页。</strong></p>
<p>​    <img src="./../images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="内存分配的函数调用"></p>
<p>​    页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 </p>
<p>​    内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口 kmalloc() 和释放内存的接口 kfree(), 支持 3 种块分配器： SLAB 分配器、 SLUB 分配器和 SLOB 分配器。</p>
<p>​    在内核初始化的过程中，页分配器还没准备好，需要使用临时的引导内存分配器分配内存。</p>
<p>​    （2）内核空间的扩展功能</p>
<p>​    <strong>不连续页分配器</strong>提供了分配内 存的接口 vmalloc 和释放内存的接口 vfree, 在内存碎片化的时候，申请连续物理页的成功率很低，可以申请不连续的物理页，映射到连续的虚拟页，即虚拟地址连续而物理地址不连续。</p>
<p>​    **连续内存分配器 (Contiguous Memory Allocator, CMA) **用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用。</p>
<p>​    当内存碎片化的时候，找不到连续的物理页，内存碎片整理(“memory compaction”  的意译，直译为“内存紧缩＂）通过迁移的方式得到连续的物理页。</p>
<p>​    在内存不足的时候，页回收负责回收物理页，对于没有后备存储设备支持的匿名页， 把数据换出到交换区，然后释放物理页；对于有后备存储设备支待的文件页，把数据写回存储设备，然后释放物理页。如果页回收失败，使用最后一招：<strong>内存耗尽杀手 (OOM killer,  Out-of-Memory killer), 选择进程杀掉</strong>。</p>
<h3 id="硬件层面"><a href="#硬件层面" class="headerlink" title="硬件层面"></a>硬件层面</h3><p>​    处理器包含一个称为<strong>内存管理单元 (Memory Management Unit, MMU)</strong> 的部件，负责把虚拟地址转换成物理地址。</p>
<p>​    内存管理单元包含一个称为**页表缓存 (Translation Lookaside Buffer, TLB) **的部件， 保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表。 </p>
<p>​    为了解决处理器的执行速度和内存的访问速度不匹配的问题，在处理器和内存之间增加了缓存。缓存通常分为 一级缓存和二级缓存，为了支持并行地取指令和取数据，一级缓存分为数据缓存和指令缓存。</p>
<h2 id="虚拟地址空间布局"><a href="#虚拟地址空间布局" class="headerlink" title="虚拟地址空间布局"></a>虚拟地址空间布局</h2><h3 id="虚拟地址空间划分"><a href="#虚拟地址空间划分" class="headerlink" title="虚拟地址空间划分"></a>虚拟地址空间划分</h3><p>​    因为目前应用程序没有那么大的内存需求，所以 ARM64 处理器不支持完全的 64 位虚 拟地址，实际支持情况如下。</p>
<p>​    （1）虚拟地址的最大宽度是 48 位，如图所示。高 16 位是全 1 或全 0 的地址称为规范的地址，两者之间是不规范的地址，不允许使用。</p>
<p><img src="./../images/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.png" alt="48位虚拟地址空间划分"></p>
<p>​    （2）如果处理器实现了 ARMv8.2 标准的大虚拟地址 (Large Virtual Address, LVA) 支持，并且页长度是 64KB, 那么虚拟地址的最大宽度是 52 位。</p>
<p>​    所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间，同一个线程组的用户线程共享用户虚拟地址空间，内核线程没有用户虚拟地址空间。</p>
<h3 id="用户虚拟地址空间布局"><a href="#用户虚拟地址空间布局" class="headerlink" title="用户虚拟地址空间布局"></a>用户虚拟地址空间布局</h3><p>​    用户进程虚拟地址空间包括以下区域。</p>
<ol>
<li>代码段、 数据段和未初始化的数据段。 </li>
<li>动态库的代码段、数据段和未初始化的数据段。</li>
<li>存放动态生成的数据的堆。</li>
<li>存放局部变量和函数调用的栈。 </li>
<li>存放在栈底部的环境变量和参数字符串。</li>
<li>把文件区间映射到虚拟地址空间的内存映射区域。</li>
</ol>
<p>​    进程是正在执行的程序，是可执行程序的动态实例，它是一个承担分配系统资源的实体，但操作系统创建进程时，会为进程创建相应的内存空间，这个内存空间称为进程的地址空间，每一个进程的地址空间都是独立的！</p>
<p>​    <img src="./../images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="虚拟内存"></p>
<p>​    当一个进程有了进程的地址空间，那么进程的地址空间就必须被相应的工具所管理，这个工具被称为内存描述符 mm_struct ,它被定义在<strong>include/linux/mm_types.h</strong>中，在Linux操作系统中是这样管理进程的地址空间的，如下图所示：</p>
<p><img src="./../images/mm_struct.png" alt="mm_struct"></p>
<p>​    mm_struct 的<strong>部分</strong>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* 指向线性区对象的链表头 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>				<span class="comment">/* 指向线性区对象的红－黑树 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在进程地址空间中搜索有效线性地址区间的方法 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_base;	<span class="comment">/* base of mmap area */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base; <span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Base adresses for compatible mmap() */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_compat_base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_compat_legacy_base;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> task_size;		<span class="comment">/* size of task vm space 用户虚拟地址空间的长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;		<span class="comment">/* highest vma end address */</span></span><br><span class="line">	<span class="type">pgd_t</span> * pgd; 	<span class="comment">/* 指向进程页表起始地址 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">atomic_t</span> mm_users;  <span class="comment">/* 共享同一个用户虚拟地址空间的进程的数量 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 内存描述符的主使用计数器，每次mm_count递减时，内核都要检查它是否变为0，如果是，就要解除这个内	 存描述符，因为不再有用户使用它</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span> mm_count;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_ptes;			<span class="comment">/* 进程中用于pte的页数 */</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_pmds;			<span class="comment">/* 进程中用于pmd的页数 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> map_count;				<span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span> page_table_lock;		<span class="comment">/* 线性区的自旋锁和页表的自旋锁 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span><span class="comment">/* 存放链表相邻元素的地址，第一个元素是init_mm的mm_list字段 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;	<span class="comment">/* 进程所拥有的最大页框数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;	<span class="comment">/* 进程线性区中的最大页数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_vm;		<span class="comment">/* 进程地址空间的大小 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> locked_vm;	<span class="comment">/* &quot;锁住&quot;而不能换出的页的个数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pinned_vm;	<span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_vm;		<span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> exec_vm;		<span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_vm;		<span class="comment">/* 用户态堆栈中的页数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> def_flags;	<span class="comment">/* 线性区默认的访问标志 */</span></span><br><span class="line">    <span class="comment">/*  可执行代码开始地址，结束地址，已初始化数据的开始地址，结束地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="comment">/* 堆的起始地址，堆的当前最后地址，用户态堆栈的起始地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="comment">/* 命令行参数的起始地址，命令行参数的最后地址，环境变量的起始地址，环境变量的最后地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">	<span class="comment">/* 开始执行ELF程序时会使用到saved_auxv参数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    进程描述符(task_struct)中和内存描述符(mm_struct)相关的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>  <span class="comment">/* 进程的mm指向一个内存描述符</span></span><br><span class="line"><span class="comment">						内核线程没有用户虚拟地址空间，所以mm是空指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span>  <span class="comment">/* 进程的active_mm 和 mm总是指向同一个内存描述</span></span><br><span class="line"><span class="comment">			内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符 */</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="cl5g7cjsi0001sw7wegbh5s1c" data-title="第三章:内存管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" rel="tag">地址映射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" rel="tag">虚拟地址</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第二章-进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-07-10T02:36:43.000Z" itemprop="datePublished">2022-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">第二章:进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​    Linux 内核把进程称为任务 (task), 进程的虚拟地址空间分为用户虚拟地址空间和内核虚拟地址空间，所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间。</p>
<p>​    <strong>进程描述符 task_struct</strong> 被定义在sched.h头文件中：<strong>include\linux\sched.h</strong></p>
<p>​    其中重要的成员变量如下：</p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile long state;</td>
<td align="center">进程的状态。 -1 unrunnable, 0 runnable, &gt;0 stopped</td>
</tr>
<tr>
<td align="center">void *stack;</td>
<td align="center">指向内核栈</td>
</tr>
<tr>
<td align="center">pid_t pid;</td>
<td align="center">全局的进程号</td>
</tr>
<tr>
<td align="center">pid_t tgid;</td>
<td align="center">全局的线程组标识符</td>
</tr>
<tr>
<td align="center">struct pid_link pids[PIDTYPE_MAX];</td>
<td align="center">进程号，进程组标识符和会话标识符</td>
</tr>
<tr>
<td align="center">struct task_struct __ rcu *real_parent; <br />struct task_struct __rcu *parent;</td>
<td align="center">real_parent指向真实的父进程。<br />parent 指向父进程：如果进程被另一个进程（通常是调试器）<br />使用系统调用ptrace跟踪，那么父进程是跟踪进程，否则和 real_parent相同</td>
</tr>
<tr>
<td align="center">char comm[TASK_COMM_LEN];</td>
<td align="center">进程名称</td>
</tr>
<tr>
<td align="center">int prio,static_prio,normal_prio;<br/>unsigned int rt__priority; <br />unsigned int policy;</td>
<td align="center">调度策略和优先级</td>
</tr>
<tr>
<td align="center">cpumask_t cpus_allowed;</td>
<td align="center">允许进程在哪些处理器上运行</td>
</tr>
<tr>
<td align="center">struct mm_struct *mm, *active_mm;</td>
<td align="center">指向内存描述符<br />进程：mm 和 active_mm指向同一个内存描述符<br />内核线程：mm是空指针，当内核线程运行时， active_mm指向从进程借用的内存描述符</td>
</tr>
<tr>
<td align="center">struct fs struct *fs;</td>
<td align="center">文件系统信息，主要是进程的根目录和当前工作目录</td>
</tr>
<tr>
<td align="center">struct files_struct *files;</td>
<td align="center">打开文件表</td>
</tr>
<tr>
<td align="center">struct nsproxy *nsproxy;</td>
<td align="center">命名空间</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="cl5g7cjse0000sw7w4g1z4umi" data-title="第二章:进程管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第一章-内核引导和初始化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2022-07-09T11:35:25.000Z" itemprop="datePublished">2022-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">第一章:内核引导和初始化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​    处理器上电以后，首先执行<strong>引导程序</strong>，引导程序把内核加载到内存，然后执行内核，内核初始化完成以后，启动用户空间的第一个进程。</p>
<h2 id="引导程序在哪读取？"><a href="#引导程序在哪读取？" class="headerlink" title="引导程序在哪读取？"></a>引导程序在哪读取？</h2><p>​    处理器在上电时自动把程序计数器设置为处理器厂商设计的某个固定值，对于 ARM64 处理器，这个固定值是0。处理器的内存管理单元 (Memory Management Unit, MMU) 负责把虚拟地址转换为物理地址， <strong>ARM64 处理器刚上电的时候是没有开启内存管理单元的，物理地址和虚拟地址相同</strong>，所以 ARM64 处理器到物理地址 0 取第一条指令。嵌入式设备通常使用 NOR 闪存作为只读存储器来存放引导程序。从物理地址 0 开始的一段物理地址空间被分配给 NOR 闪存。</p>
<p>​    ARM64 处理器到虚拟地址 0 取指令，就是到物理地址 0 取指令，也就是到 NOR 闪存的起始位置取指令。</p>
<h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>​    ARM64 处理器的 U-Boot(Universal Boot Loader) 程序的执行入口是文件 “arch/arm/cp armv8/start.S” 定义的标号_start 。</p>
<p>​    为U-Boot分配临时栈，并将引导程序复制到内存中。当引导程序初始化完成后，开始执行其中的命令，其中重要的操作是<strong>函数 bootm_find_os 把内核镜像从存储设备读到内存，函数 bootm_load_os 把内核加载到正确的位置，如果内核镜像是被压缩过的，需要解压缩。</strong></p>
<h2 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h2><p>​    内核初始化分为汇编语言部分和 C 语言部分。</p>
<h3 id="汇编部分"><a href="#汇编部分" class="headerlink" title="汇编部分"></a>汇编部分</h3><p>​    汇编部分的主要处理如下：</p>
<p>​    <strong>arch/arm64/kernel/head.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">	bl	preserve_boot_args</span><br><span class="line">	bl	el2_setup			// Drop to EL1, w0=cpu_boot_mode</span><br><span class="line">	adrp	x23, __PHYS_OFFSET</span><br><span class="line">	and	x23, x23, MIN_KIMG_ALIGN - 1	// KASLR offset, defaults to 0</span><br><span class="line">	bl	set_cpu_boot_mode_flag</span><br><span class="line">	bl	__create_page_tables</span><br><span class="line">	/*</span><br><span class="line">	 * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class="line">	 * details.</span><br><span class="line">	 * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line">	 * the TCR will have been set.</span><br><span class="line">	 */</span><br><span class="line">	bl	__cpu_setup			// initialise processor</span><br><span class="line">	b	__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>

<p>​    第 7 行代码，调用函数 __ __create_page_tables __, 创建页表映射。</p>
<p>​    第 14 行代码，调用函数 __ <strong>cpu_setup</strong>, 为开启处理器的内存管理单元做准备，初始化处理器。</p>
<p>​    第 15 行代码，调用函数 __ <strong>primary_switch</strong>, 为主处理器开启内存管理单元，搭建 C 语言执行环境，进入 C 语言部分的入口函数 start_kernel 。</p>
<h4 id="create-page-tables函数"><a href="#create-page-tables函数" class="headerlink" title="__create_page_tables函数"></a>__create_page_tables函数</h4><p>​    函数 _<em>create_page_tables</em> 的主要工作如下</p>
<p>​     (1) 创建恒等映射（identity mapping）</p>
<p>​     (2) 为内核镜像创建映射。 </p>
<p>​    恒等映射的特点是虚拟地址和物理地址相同，是为了在开启处理器的内存管理单元的一瞬间能够平滑过渡。函数 __<em>enable_mnu</em> 负责开启内存管理单元，内核把函数 <em>enable_mmu</em> 附近的代码放在恒等映射代码节 (.idmap.text) 里面，恒等映射代码节的起始地址存放在全局变量 <strong>_idmap_text_start</strong> 中，结束地址存放在全局变 **idmap_text_end **中。 </p>
<p>​    恒等映射是为恒等映射代码节创建的映射， <strong>idmap_pg_dir</strong> 是恒等映射的页全局目录（即第一级页表）的起始地址。在内核的页表中为内核镜像创建映射，内核镜像的起始地址是 _<em>text</em>, 结束地址是 _end, <strong>swapper_pg_dir</strong>是内核的页全局目录的起始地址。</p>
<h4 id="primary-switch函数"><a href="#primary-switch函数" class="headerlink" title="__primary_switch函数"></a>__primary_switch函数</h4><p>​        函数**__primary_switch** 的主要执行流程如下：</p>
<ol>
<li>​    调用函数__enable_mmu 以开启内存管理单元</li>
<li>​    调用函数**__primary_switched** 函数(不是 switch 函数）</li>
</ol>
<p>​        <strong>enable_mmu</strong> 的主要执行流程如下：</p>
<ol>
<li>​    把转换表基准寄存器 0 (TTBR0_EL1) 设置为恒等映射的页全局目录的起始物理地址。</li>
<li>​    把转换表基准寄存器 1 (TTBR1_EL1) 设置为内核的页全局目录的起始物理地址。</li>
<li>​    设置系统控制寄存器 (SCTLR_EL1), 开启内存管理单元，以后执行程序时内存管理单元将会把虚拟地址转换成物理地址。</li>
</ol>
<p>​        函数**__primary_switched** 的执行流程如下：</p>
<p>​    (1) 把当前异常级别的栈指针寄存器设置为 0 号线程内核栈的顶部 (init_thread_union +  THREAD_ SIZE) </p>
<p>​    (2) 把异常级别 0 的栈指针寄存器( SP_EL0) 设置为 0 号线程的结构体 thread_info 地址 (init_task.thread_info)</p>
<p>​    (3) 把向量基准地址寄存器 (VBAR_EL1) 设置为异常向量表的起始地址 (vectors) </p>
<p>​    (4) 计算内核镜像的起始虚拟地址 (kimage_vaddr) 和物理地址的差值，保存在全局变量 kimage_voffset 中</p>
<p>​    (5) 用 0 初始化内核的未初始化数据段 </p>
<p>​    (6) 调用 C 语言函数 start_kernel</p>
<h3 id="C语言部分"><a href="#C语言部分" class="headerlink" title="C语言部分"></a>C语言部分</h3><p>​    内核初始化的 C 语言部分入口是函数 start_kernel, 函数 start_kernel 首先初始化基础设施，即初始化内核的各个子系统，然后调用函数 rest_init 函数。rest_init 的执行流程如下。</p>
<p>​    (1) 创建 1 号线程，即 init 线程，线程函数是 kernel_init </p>
<p>​    (2) 创建 2 号线程，即 kthreadd 线程，负责创建内核线程</p>
<p>​    (3) 0 号线程最终变成空闲线程</p>
<p>​    init 线程继续初始化，执行的主要操作如下：</p>
<p>​    (1) smp_prepare_cpus(): 在启动从处理器以前执行准备工作 </p>
<p>​    (2) do_pre_smp_initcalls(): 执行必须在初始化 SMP 系统以前执行的早期初始化，即使用宏 early_initcall 注册的初始化函数。 </p>
<p>​    (3) smp_init(): 初始化 SMP 系统，启动所有从处理器。 </p>
<p>​    (4) do_initcalls(): 执行级别 0~7 的初始化。 </p>
<p>​    (5) 打开控制台的字符设备文件 “/dev/console”, 文件描述符0、1 和 2 分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。</p>
<p>​    (6) prepare_namespace(): 挂载根文件系统，后面装载 init 程序时需要从存储设备上的文件系统中读文件。 </p>
<p>​    (7) free_initmem(): 释放初始化代码和数据占用的内存。 </p>
<p>​    (8) 装载 init 程序 (U-Boot 程序可以传递内核参数 “init= “ 以指定 init 程序），从内核线程转换成用户空间的 init 进程。</p>
<h4 id="do-initcalls-函数"><a href="#do-initcalls-函数" class="headerlink" title="do_initcalls()函数"></a>do_initcalls()函数</h4><p>​    级别 0~7 的初始化，是指使用以下宏注册的初始化函数：</p>
<p>​    **include/linux/init.h **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)		__define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)		__define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)		__define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)		__define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)	__define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)		__define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)		__define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)		__define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)	__define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)			__define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)		__define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)		__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)		__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)	__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)		__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)		__define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<h4 id="SMP系统"><a href="#SMP系统" class="headerlink" title="SMP系统"></a>SMP系统</h4><p>​    对称多处理器 (Symmetric Multi-Processor, SMP) 系统包含多个处理器，并且每个处理器的地位平等。在启动过程中 ，处理器的地位不是平等的， 0 号处理器称为引导处理器， 负责执行引导程序和初始化内核；其他处理器称为从处理器，等待引导处理器完成初始化。 引导处理器初始化内核以后，启动从处理器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" data-id="cl5dta9by0000tw7w3a705eu6" data-title="第一章:内核引导和初始化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag">初始化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ctFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/08/ctFS/" class="article-date">
  <time class="dt-published" datetime="2022-07-08T02:18:07.000Z" itemprop="datePublished">2022-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/08/ctFS/">ctFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="./../images/Access-Time-for-PM.png" alt="PM的访问"></p>
<p>​    PM 的出现降低了非易失性内存和DRAM的性能差距，并且带来了可字节访问的特性。当前一些针对 PM 优化的文件系统，要么使用DAX技术来绕过 Page Cache ；要么通过将不同的文件系统数据结构映射到用户空间来绕过内核，以减少由用户态切换到内核态的开销。</p>
<p><img src="./../images/Ext4-DAX-Indexing-Path.png" alt="Ext4-DAX Index path"></p>
<p>​    然而上述文件系统的索引结构还是传统的 tree-based。这种树型的索引结构是在 unix 系统时期提出的，当时内存和持久存储(磁盘)的访问速度相差几个数量级，主要的开销主要是对持久外存的访问。然而，PM 的出现让这种速度差异已经显着缩小到几乎可以忽略不计的程度。并且PM的低延迟反过来又将瓶颈从 I/O 转移到了文件索引开销上。据作者的实验显示，即便是ext4-dax模式，某些情况内存索引的开销占总开销的 45%。</p>
<p><img src="./../public/images/image-20220721212356546.png" alt="image-20220721212356546"></p>
<h2 id="方案与设计"><a href="#方案与设计" class="headerlink" title="方案与设计"></a>方案与设计</h2><p>​    <strong>提出ctFS文件系统使用连续文件分配来代替文件索引。</strong></p>
<p>​    ctFS使用持久页表 (PPT，Persistent Page Table) 管理文件的虚拟到物理映射。 PPT 与 DRAM 中的常规易失页表具有相似的结构，不同之处在于 PPT 永久存储在 PM 上。在 ctFS 内存区域内的地址出现页面错误时，操作系统会查找 PPT 并在基于 DRAM 的页表中创建相同的映射。因此，子序列访问由 MMU 提供查询DRAM中页表的服务，从而避免了索引成本。</p>
<hr>
<p>​    <strong>ctFS的架构</strong></p>
<p>​    <img src="./../images/Architecture-of-ctFS.jpg" alt="ctFS的架构"></p>
<p>​    ctFS 的架构如图所示，由两个组件组成：(1) 提供文件系统抽象的用户空间文件系统库 ctU，以及 (2) 提供虚拟内存抽象的内核子系统 ctK。 ctU 实现文件系统结构并将其映射到虚拟内存空间。 ctK 使用存储在 PM 中的持久页表 (PPT) 将虚拟地址映射到 PM 的物理地址。ctU 地址范围内的虚拟地址上的任何页面错误都由 ctK 处理。如果 PPT 中不包含故障地址的映射，ctK 将分配一个 PM 页，在 PPT 中建立映射，然后将映射从 PPT 复制到内核的 DRAM 页表，从而实现虚拟到 PM 地址的转换由 MMU 执行。当 PPT 中的任何映射过时 时，ctK 将从 DRAM 页表中删除相应的映射，并删除 TLB 中的映射。</p>
<p>​    <strong>ctU</strong>：</p>
<p>​    ctFS 的用户空间库 ctU 将文件系统的虚拟内存空间组织成分层分区，以促进连续分配。ctFS采用类似于Linux 的伙伴分配算法来管理虚拟地址空间，并将它们分层，每个level之间的大小差距是8倍，和地址的对应的关系对应如下：</p>
<p><img src="./../images/size-of-partition.jpg" alt="size of partition"></p>
<p>​    虚拟内存区域被划分为两个 L9 分区。第一个 L9 分区是用于存储文件系统元数据的特殊分区：超级块、inode 的位图以及 inode 本身。每个 inode 存储文件的元数据（例如，所有者、组、保护、大小等）和一个字段，用于标识包含文件数据的分区的虚拟内存地址。 inode 位图用于跟踪是否分配了 inode。第二个 L9 分区用于数据存储。</p>
<p><img src="./../images/Layout-of-ctFS.jpg" alt="Layout of ctFS"></p>
<p>​    对于空闲页的查找，ctFS设置了一个表头来加速查找，对于L4-L9，会利用第一个页去保存使用状态，对于后面的三个层级，用一个页去表述空闲资源有些浪费，转为利用bitmap去表示。</p>
<p>​    <strong>ctK:</strong></p>
<p>​    由于地址空间布局随机化，内存区域可能会在不同进程中映射到不同的起始虚拟地址，并且硬件重新配置可能会更改 PM 的起始物理地址。虽然每个进程都有自己的 DRAM 页表，但 ctK 有一个 PPT，其中包含 ctU 内存范围内所有虚拟地址的映射（即分区内的那些）。 MMU 无法访问 PPT，因此 PPT 中的映射用于按需填充 DRAM 页表中的条目，作为页面错误处理的一部分。</p>
<p>​    <strong>ctK 负责管理PPT，对于虚拟地址和物理地址，ctFS都采用的相对地址，为每个进程映射到不同的虚拟地址</strong></p>
<hr>
<p>​    <strong>Pswap系统调用：</strong></p>
<p>​    最初，一个文件被分配在一个分区中，该分区的大小刚好足以容纳该文件。当文件超出其分区时，它会被移动到虚拟内存中更大的分区，而无需复制任何物理持久内存。 ctFS 通过使用 pswap 将文件的物理页面重新映射到新分区来做到这一点，这是一种新的操作系统系统调用，可以原子地交换虚拟到物理的映射。原子交换还可以在多块写入时实现高效的崩溃一致性，而无需重复写入数据。 ctFS 中的原子写入只是将数据写入新空间，然后将其与旧数据进行 pswaps。</p>
<p>​    <img src="./../images/Pswap.jpg" alt="Pswap"></p>
<p>​        上图展示了一个例子，其中 pswap 需要交换两个页面序列 A 和 B， 两个序列都包含 262658 (512 × 512 + 512 + 2) 个页面。 交换两个序列的数据时，使用pswap 只需要交换 4 对页表条目或目录，因为所有 262,658 个页面都被单个 PUD 条目覆盖（覆盖 512×512 个页面），单个 PMD 条目（涵盖 512 页）和两个 PTE 条目（涵盖 2 页）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/08/ctFS/" data-id="cl5bu6cjv0000g07w9vypf1jw" data-title="ctFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DAX/" rel="tag">DAX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PM/" rel="tag">PM</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2022/" rel="tag">2022</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COW/" rel="tag">COW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAX/" rel="tag">DAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ISAC/" rel="tag">ISAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PMDK/" rel="tag">PMDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/" rel="tag">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XFS/" rel="tag">XFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zero-Copy/" rel="tag">Zero Copy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easy/" rel="tag">easy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mmap/" rel="tag">mmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflink/" rel="tag">reflink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag">初始化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" rel="tag">地址映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" rel="tag">虚拟地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="tag">论文阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/2022/" style="font-size: 10px;">2022</a> <a href="/tags/COW/" style="font-size: 10px;">COW</a> <a href="/tags/DAX/" style="font-size: 15px;">DAX</a> <a href="/tags/File-System/" style="font-size: 15px;">File System</a> <a href="/tags/ISAC/" style="font-size: 10px;">ISAC</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 20px;">Linux内核</a> <a href="/tags/PM/" style="font-size: 15px;">PM</a> <a href="/tags/PMDK/" style="font-size: 15px;">PMDK</a> <a href="/tags/Security/" style="font-size: 10px;">Security</a> <a href="/tags/XFS/" style="font-size: 10px;">XFS</a> <a href="/tags/Zero-Copy/" style="font-size: 10px;">Zero Copy</a> <a href="/tags/easy/" style="font-size: 10px;">easy</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/mmap/" style="font-size: 10px;">mmap</a> <a href="/tags/reflink/" style="font-size: 10px;">reflink</a> <a href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" style="font-size: 20px;">《Linux内核深度解析(余华兵)》</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 10px;">内存分配</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 10px;">初始化</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" style="font-size: 10px;">地址映射</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">虚拟地址</a> <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 10px;">论文阅读</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 10px;">进程管理</a> <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">阅读笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/30/copy-cow-page-dax/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/19/CreateObj-in-PMDK/">CreateObj in PMDK</a>
          </li>
        
          <li>
            <a href="/2022/07/16/%E5%89%91%E6%8C%87-Offer-II-041-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/">剑指 Offer II 041. 滑动窗口的平均值</a>
          </li>
        
          <li>
            <a href="/2022/07/15/PS-ORAM/">PS-ORAM</a>
          </li>
        
          <li>
            <a href="/2022/07/13/SubZero/">SubZero</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Wjt1127<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>