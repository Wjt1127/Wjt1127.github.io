<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wjt1127 Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Wjt1127 Blog">
<meta property="og:url" content="https://wjt1127.github.io/index.html">
<meta property="og:site_name" content="Wjt1127 Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Wjt1127">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Wjt1127 Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wjt1127 Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wjt1127.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-第三章-内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-07-11T01:39:41.000Z" itemprop="datePublished">2022-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">第三章:内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="内存管理框架"><a href="#内存管理框架" class="headerlink" title="内存管理框架"></a>内存管理框架</h2><p>​    内存管理子系统的架构如下图所示，分为用户空间、内核空间和硬件 3 个层面。</p>
<p><img src="./../images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6.png" alt="内存管理框架"></p>
<h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>​    应用程序使用 malloc() 申请内存，使用 free() 释放内存。</p>
<p>​    malloc() 和 free() 是 glibc 库的内存分配器 ptmalloc 提供的接口， ptmalloc 使用系统调用 brk 或 mmap 向内 核以页为单位申请内存 ， 然后划分成小内存块分配给应用程序。</p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>​    （1）内核空间的基本功能</p>
<p>​    虚拟内存管理负责从进程的虚拟地址空间分配虚拟页， sys_brk 用来扩大或收缩堆， sys_mmap 用来在内存映射区域分配虚拟页， sys_munmap 用来释放虚拟页。</p>
<p>​    <strong>内核使用延迟分配物理内存的策略，进程第 1 次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页。</strong></p>
<p>​    <img src="./../images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="内存分配的函数调用"></p>
<p>​    页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 </p>
<p>​    内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口 kmalloc() 和释放内存的接口 kfree(), 支持 3 种块分配器： SLAB 分配器、 SLUB 分配器和 SLOB 分配器。</p>
<p>​    在内核初始化的过程中，页分配器还没准备好，需要使用临时的引导内存分配器分配内存。</p>
<p>​    （2）内核空间的扩展功能</p>
<p>​    <strong>不连续页分配器</strong>提供了分配内 存的接口 vmalloc 和释放内存的接口 vfree, 在内存碎片化的时候，申请连续物理页的成功率很低，可以申请不连续的物理页，映射到连续的虚拟页，即虚拟地址连续而物理地址不连续。</p>
<p>​    **连续内存分配器 (Contiguous Memory Allocator, CMA) **用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用。</p>
<p>​    当内存碎片化的时候，找不到连续的物理页，内存碎片整理(“memory compaction”  的意译，直译为“内存紧缩＂）通过迁移的方式得到连续的物理页。</p>
<p>​    在内存不足的时候，页回收负责回收物理页，对于没有后备存储设备支持的匿名页， 把数据换出到交换区，然后释放物理页；对于有后备存储设备支待的文件页，把数据写回存储设备，然后释放物理页。如果页回收失败，使用最后一招：<strong>内存耗尽杀手 (OOM killer,  Out-of-Memory killer), 选择进程杀掉</strong>。</p>
<h3 id="硬件层面"><a href="#硬件层面" class="headerlink" title="硬件层面"></a>硬件层面</h3><p>​    处理器包含一个称为<strong>内存管理单元 (Memory Management Unit, MMU)</strong> 的部件，负责把虚拟地址转换成物理地址。</p>
<p>​    内存管理单元包含一个称为**页表缓存 (Translation Lookaside Buffer, TLB) **的部件， 保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表。 </p>
<p>​    为了解决处理器的执行速度和内存的访问速度不匹配的问题，在处理器和内存之间增加了缓存。缓存通常分为 一级缓存和二级缓存，为了支持并行地取指令和取数据，一级缓存分为数据缓存和指令缓存。</p>
<h2 id="虚拟地址空间布局"><a href="#虚拟地址空间布局" class="headerlink" title="虚拟地址空间布局"></a>虚拟地址空间布局</h2><h3 id="虚拟地址空间划分"><a href="#虚拟地址空间划分" class="headerlink" title="虚拟地址空间划分"></a>虚拟地址空间划分</h3><p>​    因为目前应用程序没有那么大的内存需求，所以 ARM64 处理器不支持完全的 64 位虚 拟地址，实际支持情况如下。</p>
<p>​    （1）虚拟地址的最大宽度是 48 位，如图所示。高 16 位是全 1 或全 0 的地址称为规范的地址，两者之间是不规范的地址，不允许使用。</p>
<p><img src="./../images/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.png" alt="48位虚拟地址空间划分"></p>
<p>​    （2）如果处理器实现了 ARMv8.2 标准的大虚拟地址 (Large Virtual Address, LVA) 支持，并且页长度是 64KB, 那么虚拟地址的最大宽度是 52 位。</p>
<p>​    所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间，同一个线程组的用户线程共享用户虚拟地址空间，内核线程没有用户虚拟地址空间。</p>
<h3 id="用户虚拟地址空间布局"><a href="#用户虚拟地址空间布局" class="headerlink" title="用户虚拟地址空间布局"></a>用户虚拟地址空间布局</h3><p>​    用户进程虚拟地址空间包括以下区域。</p>
<ol>
<li>代码段、 数据段和未初始化的数据段。 </li>
<li>动态库的代码段、数据段和未初始化的数据段。</li>
<li>存放动态生成的数据的堆。</li>
<li>存放局部变量和函数调用的栈。 </li>
<li>存放在栈底部的环境变量和参数字符串。</li>
<li>把文件区间映射到虚拟地址空间的内存映射区域。</li>
</ol>
<p>​    进程是正在执行的程序，是可执行程序的动态实例，它是一个承担分配系统资源的实体，但操作系统创建进程时，会为进程创建相应的内存空间，这个内存空间称为进程的地址空间，每一个进程的地址空间都是独立的！</p>
<p>​    <img src="./../images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="虚拟内存"></p>
<p>​    当一个进程有了进程的地址空间，那么进程的地址空间就必须被相应的工具所管理，这个工具被称为内存描述符 mm_struct ,它被定义在<strong>include/linux/mm_types.h</strong>中，在Linux操作系统中是这样管理进程的地址空间的，如下图所示：</p>
<p><img src="./../images/mm_struct.png" alt="mm_struct"></p>
<p>​    mm_struct 的<strong>部分</strong>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* 指向线性区对象的链表头 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>				<span class="comment">/* 指向线性区对象的红－黑树 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在进程地址空间中搜索有效线性地址区间的方法 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_base;	<span class="comment">/* base of mmap area */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base; <span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Base adresses for compatible mmap() */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_compat_base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_compat_legacy_base;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> task_size;		<span class="comment">/* size of task vm space 用户虚拟地址空间的长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;		<span class="comment">/* highest vma end address */</span></span><br><span class="line">	<span class="type">pgd_t</span> * pgd; 	<span class="comment">/* 指向进程页表起始地址 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">atomic_t</span> mm_users;  <span class="comment">/* 共享同一个用户虚拟地址空间的进程的数量 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 内存描述符的主使用计数器，每次mm_count递减时，内核都要检查它是否变为0，如果是，就要解除这个内	 存描述符，因为不再有用户使用它</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span> mm_count;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_ptes;			<span class="comment">/* 进程中用于pte的页数 */</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_pmds;			<span class="comment">/* 进程中用于pmd的页数 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> map_count;				<span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span> page_table_lock;		<span class="comment">/* 线性区的自旋锁和页表的自旋锁 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span><span class="comment">/* 存放链表相邻元素的地址，第一个元素是init_mm的mm_list字段 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;	<span class="comment">/* 进程所拥有的最大页框数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;	<span class="comment">/* 进程线性区中的最大页数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_vm;		<span class="comment">/* 进程地址空间的大小 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> locked_vm;	<span class="comment">/* &quot;锁住&quot;而不能换出的页的个数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pinned_vm;	<span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_vm;		<span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> exec_vm;		<span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_vm;		<span class="comment">/* 用户态堆栈中的页数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> def_flags;	<span class="comment">/* 线性区默认的访问标志 */</span></span><br><span class="line">    <span class="comment">/*  可执行代码开始地址，结束地址，已初始化数据的开始地址，结束地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="comment">/* 堆的起始地址，堆的当前最后地址，用户态堆栈的起始地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="comment">/* 命令行参数的起始地址，命令行参数的最后地址，环境变量的起始地址，环境变量的最后地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">	<span class="comment">/* 开始执行ELF程序时会使用到saved_auxv参数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    进程描述符(task_struct)中和内存描述符(mm_struct)相关的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>  <span class="comment">/* 进程的mm指向一个内存描述符</span></span><br><span class="line"><span class="comment">						内核线程没有用户虚拟地址空间，所以mm是空指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span>  <span class="comment">/* 进程的active_mm 和 mm总是指向同一个内存描述</span></span><br><span class="line"><span class="comment">			内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符 */</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="cl5g7cjsi0001sw7wegbh5s1c" data-title="第三章:内存管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" rel="tag">地址映射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" rel="tag">虚拟地址</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第二章-进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-07-10T02:36:43.000Z" itemprop="datePublished">2022-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">第二章:进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​    Linux 内核把进程称为任务 (task), 进程的虚拟地址空间分为用户虚拟地址空间和内核虚拟地址空间，所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间。</p>
<p>​    <strong>进程描述符 task_struct</strong> 被定义在sched.h头文件中：<strong>include\linux\sched.h</strong></p>
<p>​    其中重要的成员变量如下：</p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile long state;</td>
<td align="center">进程的状态。 -1 unrunnable, 0 runnable, &gt;0 stopped</td>
</tr>
<tr>
<td align="center">void *stack;</td>
<td align="center">指向内核栈</td>
</tr>
<tr>
<td align="center">pid_t pid;</td>
<td align="center">全局的进程号</td>
</tr>
<tr>
<td align="center">pid_t tgid;</td>
<td align="center">全局的线程组标识符</td>
</tr>
<tr>
<td align="center">struct pid_link pids[PIDTYPE_MAX];</td>
<td align="center">进程号，进程组标识符和会话标识符</td>
</tr>
<tr>
<td align="center">struct task_struct __ rcu *real_parent; <br />struct task_struct __rcu *parent;</td>
<td align="center">real_parent指向真实的父进程。<br />parent 指向父进程：如果进程被另一个进程（通常是调试器）<br />使用系统调用ptrace跟踪，那么父进程是跟踪进程，否则和 real_parent相同</td>
</tr>
<tr>
<td align="center">char comm[TASK_COMM_LEN];</td>
<td align="center">进程名称</td>
</tr>
<tr>
<td align="center">int prio,static_prio,normal_prio;<br/>unsigned int rt__priority; <br />unsigned int policy;</td>
<td align="center">调度策略和优先级</td>
</tr>
<tr>
<td align="center">cpumask_t cpus_allowed;</td>
<td align="center">允许进程在哪些处理器上运行</td>
</tr>
<tr>
<td align="center">struct mm_struct *mm, *active_mm;</td>
<td align="center">指向内存描述符<br />进程：mm 和 active_mm指向同一个内存描述符<br />内核线程：mm是空指针，当内核线程运行时， active_mm指向从进程借用的内存描述符</td>
</tr>
<tr>
<td align="center">struct fs struct *fs;</td>
<td align="center">文件系统信息，主要是进程的根目录和当前工作目录</td>
</tr>
<tr>
<td align="center">struct files_struct *files;</td>
<td align="center">打开文件表</td>
</tr>
<tr>
<td align="center">struct nsproxy *nsproxy;</td>
<td align="center">命名空间</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="cl5g7cjse0000sw7w4g1z4umi" data-title="第二章:进程管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第一章-内核引导和初始化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2022-07-09T11:35:25.000Z" itemprop="datePublished">2022-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">第一章:内核引导和初始化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​    处理器上电以后，首先执行<strong>引导程序</strong>，引导程序把内核加载到内存，然后执行内核，内核初始化完成以后，启动用户空间的第一个进程。</p>
<h2 id="引导程序在哪读取？"><a href="#引导程序在哪读取？" class="headerlink" title="引导程序在哪读取？"></a>引导程序在哪读取？</h2><p>​    处理器在上电时自动把程序计数器设置为处理器厂商设计的某个固定值，对于 ARM64 处理器，这个固定值是0。处理器的内存管理单元 (Memory Management Unit, MMU) 负责把虚拟地址转换为物理地址， <strong>ARM64 处理器刚上电的时候是没有开启内存管理单元的，物理地址和虚拟地址相同</strong>，所以 ARM64 处理器到物理地址 0 取第一条指令。嵌入式设备通常使用 NOR 闪存作为只读存储器来存放引导程序。从物理地址 0 开始的一段物理地址空间被分配给 NOR 闪存。</p>
<p>​    ARM64 处理器到虚拟地址 0 取指令，就是到物理地址 0 取指令，也就是到 NOR 闪存的起始位置取指令。</p>
<h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>​    ARM64 处理器的 U-Boot(Universal Boot Loader) 程序的执行入口是文件 “arch/arm/cp armv8/start.S” 定义的标号_start 。</p>
<p>​    为U-Boot分配临时栈，并将引导程序复制到内存中。当引导程序初始化完成后，开始执行其中的命令，其中重要的操作是<strong>函数 bootm_find_os 把内核镜像从存储设备读到内存，函数 bootm_load_os 把内核加载到正确的位置，如果内核镜像是被压缩过的，需要解压缩。</strong></p>
<h2 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h2><p>​    内核初始化分为汇编语言部分和 C 语言部分。</p>
<h3 id="汇编部分"><a href="#汇编部分" class="headerlink" title="汇编部分"></a>汇编部分</h3><p>​    汇编部分的主要处理如下：</p>
<p>​    <strong>arch/arm64/kernel/head.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">	bl	preserve_boot_args</span><br><span class="line">	bl	el2_setup			// Drop to EL1, w0=cpu_boot_mode</span><br><span class="line">	adrp	x23, __PHYS_OFFSET</span><br><span class="line">	and	x23, x23, MIN_KIMG_ALIGN - 1	// KASLR offset, defaults to 0</span><br><span class="line">	bl	set_cpu_boot_mode_flag</span><br><span class="line">	bl	__create_page_tables</span><br><span class="line">	/*</span><br><span class="line">	 * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class="line">	 * details.</span><br><span class="line">	 * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line">	 * the TCR will have been set.</span><br><span class="line">	 */</span><br><span class="line">	bl	__cpu_setup			// initialise processor</span><br><span class="line">	b	__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>

<p>​    第 7 行代码，调用函数 __ __create_page_tables __, 创建页表映射。</p>
<p>​    第 14 行代码，调用函数 __ <strong>cpu_setup</strong>, 为开启处理器的内存管理单元做准备，初始化处理器。</p>
<p>​    第 15 行代码，调用函数 __ <strong>primary_switch</strong>, 为主处理器开启内存管理单元，搭建 C 语言执行环境，进入 C 语言部分的入口函数 start_kernel 。</p>
<h4 id="create-page-tables函数"><a href="#create-page-tables函数" class="headerlink" title="__create_page_tables函数"></a>__create_page_tables函数</h4><p>​    函数 _<em>create_page_tables</em> 的主要工作如下</p>
<p>​     (1) 创建恒等映射（identity mapping）</p>
<p>​     (2) 为内核镜像创建映射。 </p>
<p>​    恒等映射的特点是虚拟地址和物理地址相同，是为了在开启处理器的内存管理单元的一瞬间能够平滑过渡。函数 __<em>enable_mnu</em> 负责开启内存管理单元，内核把函数 <em>enable_mmu</em> 附近的代码放在恒等映射代码节 (.idmap.text) 里面，恒等映射代码节的起始地址存放在全局变量 <strong>_idmap_text_start</strong> 中，结束地址存放在全局变 **idmap_text_end **中。 </p>
<p>​    恒等映射是为恒等映射代码节创建的映射， <strong>idmap_pg_dir</strong> 是恒等映射的页全局目录（即第一级页表）的起始地址。在内核的页表中为内核镜像创建映射，内核镜像的起始地址是 _<em>text</em>, 结束地址是 _end, <strong>swapper_pg_dir</strong>是内核的页全局目录的起始地址。</p>
<h4 id="primary-switch函数"><a href="#primary-switch函数" class="headerlink" title="__primary_switch函数"></a>__primary_switch函数</h4><p>​        函数**__primary_switch** 的主要执行流程如下：</p>
<ol>
<li>​    调用函数__enable_mmu 以开启内存管理单元</li>
<li>​    调用函数**__primary_switched** 函数(不是 switch 函数）</li>
</ol>
<p>​        <strong>enable_mmu</strong> 的主要执行流程如下：</p>
<ol>
<li>​    把转换表基准寄存器 0 (TTBR0_EL1) 设置为恒等映射的页全局目录的起始物理地址。</li>
<li>​    把转换表基准寄存器 1 (TTBR1_EL1) 设置为内核的页全局目录的起始物理地址。</li>
<li>​    设置系统控制寄存器 (SCTLR_EL1), 开启内存管理单元，以后执行程序时内存管理单元将会把虚拟地址转换成物理地址。</li>
</ol>
<p>​        函数**__primary_switched** 的执行流程如下：</p>
<p>​    (1) 把当前异常级别的栈指针寄存器设置为 0 号线程内核栈的顶部 (init_thread_union +  THREAD_ SIZE) </p>
<p>​    (2) 把异常级别 0 的栈指针寄存器( SP_EL0) 设置为 0 号线程的结构体 thread_info 地址 (init_task.thread_info)</p>
<p>​    (3) 把向量基准地址寄存器 (VBAR_EL1) 设置为异常向量表的起始地址 (vectors) </p>
<p>​    (4) 计算内核镜像的起始虚拟地址 (kimage_vaddr) 和物理地址的差值，保存在全局变量 kimage_voffset 中</p>
<p>​    (5) 用 0 初始化内核的未初始化数据段 </p>
<p>​    (6) 调用 C 语言函数 start_kernel</p>
<h3 id="C语言部分"><a href="#C语言部分" class="headerlink" title="C语言部分"></a>C语言部分</h3><p>​    内核初始化的 C 语言部分入口是函数 start_kernel, 函数 start_kernel 首先初始化基础设施，即初始化内核的各个子系统，然后调用函数 rest_init 函数。rest_init 的执行流程如下。</p>
<p>​    (1) 创建 1 号线程，即 init 线程，线程函数是 kernel_init </p>
<p>​    (2) 创建 2 号线程，即 kthreadd 线程，负责创建内核线程</p>
<p>​    (3) 0 号线程最终变成空闲线程</p>
<p>​    init 线程继续初始化，执行的主要操作如下：</p>
<p>​    (1) smp_prepare_cpus(): 在启动从处理器以前执行准备工作 </p>
<p>​    (2) do_pre_smp_initcalls(): 执行必须在初始化 SMP 系统以前执行的早期初始化，即使用宏 early_initcall 注册的初始化函数。 </p>
<p>​    (3) smp_init(): 初始化 SMP 系统，启动所有从处理器。 </p>
<p>​    (4) do_initcalls(): 执行级别 0~7 的初始化。 </p>
<p>​    (5) 打开控制台的字符设备文件 “/dev/console”, 文件描述符0、1 和 2 分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。</p>
<p>​    (6) prepare_namespace(): 挂载根文件系统，后面装载 init 程序时需要从存储设备上的文件系统中读文件。 </p>
<p>​    (7) free_initmem(): 释放初始化代码和数据占用的内存。 </p>
<p>​    (8) 装载 init 程序 (U-Boot 程序可以传递内核参数 “init= “ 以指定 init 程序），从内核线程转换成用户空间的 init 进程。</p>
<h4 id="do-initcalls-函数"><a href="#do-initcalls-函数" class="headerlink" title="do_initcalls()函数"></a>do_initcalls()函数</h4><p>​    级别 0~7 的初始化，是指使用以下宏注册的初始化函数：</p>
<p>​    **include/linux/init.h **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)		__define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)		__define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)		__define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)		__define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)	__define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)		__define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)		__define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)		__define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)	__define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)			__define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)		__define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)		__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)		__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)	__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)		__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)		__define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<h4 id="SMP系统"><a href="#SMP系统" class="headerlink" title="SMP系统"></a>SMP系统</h4><p>​    对称多处理器 (Symmetric Multi-Processor, SMP) 系统包含多个处理器，并且每个处理器的地位平等。在启动过程中 ，处理器的地位不是平等的， 0 号处理器称为引导处理器， 负责执行引导程序和初始化内核；其他处理器称为从处理器，等待引导处理器完成初始化。 引导处理器初始化内核以后，启动从处理器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" data-id="cl5dta9by0000tw7w3a705eu6" data-title="第一章:内核引导和初始化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag">初始化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ctFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/08/ctFS/" class="article-date">
  <time class="dt-published" datetime="2022-07-08T02:18:07.000Z" itemprop="datePublished">2022-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/08/ctFS/">ctFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="./../images/Access-Time-for-PM.png" alt="PM的访问"></p>
<p>​    由于PM的低延迟性，PM 比磁盘存储快得多，对 PM 的访问可以像对易失性 RAM 的访问一样，由内存管理单元 (MMU) 进行管理。PM的特性将访问瓶颈从 I/O 时延转移到诸如块地址查找之类的操作上。比如，在写入工作负载中，ext4-DAX 中高达 45% 的开销是构建和搜索范围树以将文件偏移量转换为在持久内存上的地址。</p>
<p><img src="./../images/Ext4-DAX-Indexing-Path.png" alt="Ext4-DAX Index path"></p>
<p>​    当前一些针对PM 优化的文件系统，要么使用DAX技术来绕过 Page Cache ；要么通过将不同的文件系统数据结构映射到用户空间来绕过内核，以减少切换到内核的开销。所有的这些系统都使用传统的基于树的索引结构将文件偏移量转换为设备地址。<strong>这种索引结构是在内存和持久存储(磁盘)的速度相差几个数量级时提出的，然而，PM 的出现让这种速度差异已经显着缩小到几乎可以忽略不计的程度。并且PM的低延迟反过来又将瓶颈从 I/O 转移到了文件索引开销上。</strong></p>
<h2 id="方案与设计"><a href="#方案与设计" class="headerlink" title="方案与设计"></a>方案与设计</h2><p>​    <strong>提出ctFS文件系统使用连续文件分配来代替文件索引。</strong></p>
<p>​    ctFS使用持久页表 (PPT，Persistent Page Table) 管理文件的虚拟到物理映射。 PPT 与 DRAM 中的常规易失页表具有相似的结构，不同之处在于 PPT 永久存储在 PM 上。在 ctFS 内存区域内的地址出现页面错误时，操作系统会查找 PPT 并在基于 DRAM 的页表中创建相同的映射。因此，子序列访问由 MMU 提供查询DRAM中页表的服务，从而避免了索引成本。</p>
<hr>
<p>​    <strong>ctFS的架构</strong></p>
<p>​    <img src="./../images/Architecture-of-ctFS.jpg" alt="ctFS的架构"></p>
<p>​    ctFS 的架构如图所示，由两个组件组成：(1) 提供文件系统抽象的用户空间文件系统库 ctU，以及 (2) 提供虚拟内存抽象的内核子系统 ctK。 ctU 实现文件系统结构并将其映射到虚拟内存空间。 ctK 使用存储在 PM 中的持久页表 (PPT) 将虚拟地址映射到 PM 的物理地址。ctU 地址范围内的虚拟地址上的任何页面错误都由 ctK 处理。如果 PPT 中不包含故障地址的映射，ctK 将分配一个 PM 页，在 PPT 中建立映射，然后将映射从 PPT 复制到内核的 DRAM 页表，从而实现虚拟到 PM 地址的转换由 MMU 执行。当 PPT 中的任何映射过时 时，ctK 将从 DRAM 页表中删除相应的映射，并删除 TLB 中的映射。</p>
<p>​    <strong>ctU</strong>：</p>
<p>​    ctFS 的用户空间库 ctU 将文件系统的虚拟内存空间组织成分层分区，以促进连续分配。ctFS采用类似于Linux 的伙伴分配算法来管理虚拟地址空间，并将它们分层，每个level之间的大小差距是8倍，因为要和page table的多级页表先匹配，和地址的对应的关系对应如下：</p>
<p><img src="./../images/size-of-partition.jpg" alt="size of partition"></p>
<p>​    虚拟内存区域被划分为两个 L9 分区。第一个 L9 分区是用于存储文件系统元数据的特殊分区：超级块、inode 的位图以及 inode 本身。每个 inode 存储文件的元数据（例如，所有者、组、保护、大小等）和一个字段，用于标识包含文件数据的分区的虚拟内存地址。 inode 位图用于跟踪是否分配了 inode。第二个 L9 分区用于数据存储。</p>
<p><img src="./../images/Layout-of-ctFS.jpg" alt="Layout of ctFS"></p>
<p>​    对于空闲页的查找，ctFS设置了一个表头来加速查找，对于L4-L9，会利用第一个页去保存使用状态，对于后面的三个层级，用一个页去表述空闲资源有些浪费，转为利用bitmap去表示。</p>
<p>​    <strong>ctK:</strong></p>
<p>​    由于地址空间布局随机化，内存区域可能会在不同进程中映射到不同的起始虚拟地址，并且硬件重新配置可能会更改 PM 的起始物理地址。虽然每个进程都有自己的 DRAM 页表，但 ctK 有一个 PPT，其中包含 ctU 内存范围内所有虚拟地址的映射（即分区内的那些）。 MMU 无法访问 PPT，因此 PPT 中的映射用于按需填充 DRAM 页表中的条目，作为页面错误处理的一部分。</p>
<p>​    <strong>ctK 负责管理PPT，对于虚拟地址和物理地址，ctFS都采用的相对地址，为每个进程映射到不同的虚拟地址</strong></p>
<hr>
<p>​    <strong>Pswap系统调用：</strong></p>
<p>​    最初，一个文件被分配在一个分区中，该分区的大小刚好足以容纳该文件。当文件超出其分区时，它会被移动到虚拟内存中更大的分区，而无需复制任何物理持久内存。 ctFS 通过使用pswap 将文件的物理页面重新映射到新分区来做到这一点，这是一种新的操作系统系统调用，可以原子地交换虚拟到物理的映射。原子交换还可以在多块写入时实现高效的崩溃一致性，而无需重复写入数据。 ctFS 中的原子写入只是将数据写入新空间，然后将其与旧数据进行 pswaps。</p>
<p>​    <img src="./../images/Pswap.jpg" alt="Pswap"></p>
<p>​        上图展示了一个例子，其中 pswap 需要交换两个页面序列 A 和 B， 两个序列都包含 262658 (512 × 512 + 512 + 2) 个页面。 交换两个序列的数据时，使用pswap 只需要交换 4 对页表条目或目录，因为所有 262,658 个页面都被单个 PUD 条目覆盖（覆盖 512×512 个页面），单个 PMD 条目（涵盖 512 页）和两个 PTE 条目（涵盖 2 页）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/08/ctFS/" data-id="cl5bu6cjv0000g07w9vypf1jw" data-title="ctFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DAX/" rel="tag">DAX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PM/" rel="tag">PM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SplitFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/06/SplitFS/" class="article-date">
  <time class="dt-published" datetime="2022-07-06T08:41:27.000Z" itemprop="datePublished">2022-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/06/SplitFS/">SplitFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Design-of-SplitFS"><a href="#Design-of-SplitFS" class="headerlink" title="Design of SplitFS"></a>Design of SplitFS</h2><p><img src="./../images/Ext4-DAX-Indexing-Path.png" alt="Ext4-DAX的索引路"></p>
<p>SplitFS 将文件系统在逻辑上拆分为用户空间部分（U-Split）和内核空间部分（K-Split），其中 K-Split 使用 ext4-DAX。通过  U-Split 将一个文件拆分为多个 2MB 区域，其中每个区域映射到一个 ext4-DAX 文件。 USplit 和 K-Split  都参与索引：U-Split 将一个逻辑文件偏移映射到对应的 ext4-DAX 文件，K-Split 中的 ext4-DAX 进一步搜索其extent index  以获取实际物理地址。</p>
<p>SplitFS还提出了一种名为relink的新操作，以提高文件扩展的性能，并在没有双重写入数据的情况下在文件写入时提供崩溃一致性。在其同步模式下，文件增加首先添加到一个暂存文件，然后在调用fsync（）或暂存文件达到其大小限制时重新链接到目标文件；文件覆盖已应用。在严格模式下，每个文件写入，无论是覆盖还是附加数据，都会应用于暂存文件，并在每次写入结束时重新链接。因此，SplitFS  的索引时间包括内核和用户组件中的重新链接、mmap 和索引。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/06/SplitFS/" data-id="cl59lyqpl0004to7wge4z311s" data-title="SplitFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PMDK从pmemobj到物理地址的映射" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/06/PMDK%E4%BB%8Epmemobj%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84/" class="article-date">
  <time class="dt-published" datetime="2022-07-05T16:00:00.000Z" itemprop="datePublished">2022-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/06/PMDK%E4%BB%8Epmemobj%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84/">PMDK从pmemobj到物理地址的映射流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="三重映射"><a href="#三重映射" class="headerlink" title="三重映射"></a>三重映射</h1><ul>
<li>从pmemobj的ID到虚拟地址的映射</li>
<li>从虚拟地址到文件内偏移的映射</li>
<li>从文件到物理地址的映射</li>
</ul>
<h2 id="pmemobj到虚拟地址的映射"><a href="#pmemobj到虚拟地址的映射" class="headerlink" title="pmemobj到虚拟地址的映射"></a>pmemobj到虚拟地址的映射</h2><ul>
<li><p>查看pmemobj的创建函数 pmemobj_createW(src\libpmemobj\obj.c)</p>
<ol>
<li><p>pmemobj_createW —&gt; pmemobj_createU(src\libpmemobj\obj.c)</p>
</li>
<li><p>pmemobj_createU  —&gt; util_pool_create(src\common\set.c)</p>
</li>
<li><p>util_pool_create  —&gt; util_pool_create_uuids(src\common\set.c)</p>
</li>
<li><p>util_pool_create_uuids  —&gt; util_poolset_create_set(src\common\set.c)</p>
</li>
<li><p><strong>util_poolset_create_set  —&gt; util_poolset_single(src\common\set.c)</strong> </p>
</li>
<li><p>设置DAX模式就主要到util_poolset_single进行处理</p>
<p>​	其中<strong>rep-&gt;part[0].fd</strong>成员使用 <strong>util_poolset_file</strong>填充</p>
<p>​	<strong>rep-&gt;part[0].alignment</strong>使用<strong>device_dax_alignment</strong>填充</p>
</li>
</ol>
</li>
<li><p>查看pmemobj_open函数(src\libpmemobj\obj.c)</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/06/PMDK%E4%BB%8Epmemobj%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84/" data-id="cl59lyqpb0000to7w6ddu5jh1" data-title="PMDK从pmemobj到物理地址的映射流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PMDK/" rel="tag">PMDK</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-07-05T14:58:39.711Z" itemprop="datePublished">2022-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjt1127.github.io/2022/07/05/hello-world/" data-id="cl59lyqpk0003to7wbi4je26i" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAX/" rel="tag">DAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PMDK/" rel="tag">PMDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" rel="tag">《Linux内核深度解析(余华兵)》</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag">初始化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" rel="tag">地址映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" rel="tag">虚拟地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DAX/" style="font-size: 10px;">DAX</a> <a href="/tags/File-System/" style="font-size: 15px;">File System</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 20px;">Linux内核</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/PMDK/" style="font-size: 10px;">PMDK</a> <a href="/tags/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E4%BD%99%E5%8D%8E%E5%85%B5-%E3%80%8B/" style="font-size: 20px;">《Linux内核深度解析(余华兵)》</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 10px;">初始化</a> <a href="/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/" style="font-size: 10px;">地址映射</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">虚拟地址</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 10px;">进程管理</a> <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">阅读笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/11/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">第三章:内存管理</a>
          </li>
        
          <li>
            <a href="/2022/07/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">第二章:进程管理</a>
          </li>
        
          <li>
            <a href="/2022/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">第一章:内核引导和初始化</a>
          </li>
        
          <li>
            <a href="/2022/07/08/ctFS/">ctFS</a>
          </li>
        
          <li>
            <a href="/2022/07/06/SplitFS/">SplitFS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Wjt1127<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>